#include "cppdefs.h"
                                      ! Read and report model input
      subroutine read_inp (ierr)      ! parameters from keyword-based 
      implicit none                   ! startup file.
#include "param.h"
#include "scoord.h"
#include "scalars.h"
#include "ncvars.h"
#include "boundary.h"
#if defined BULK_DIAGS || defined READ_ATM_PCO2 || defined READ_VARIABLE_ATM_PCO2
#include "forces.h"
#endif
#ifndef NONLIN_EOS
# include "eos_vars.h"
#endif
#ifdef FLOATS
# include "ncvars_floats.h"
#endif
#ifdef PSOURCE
# include "sources.h"
#endif
#ifdef BGC_FLUX_ANALYSIS
# include "bgcflux.h"
# include "ncroms_bgcflux.h"
#endif
#ifdef PHYS_FLUX_ANALYSIS
# include "physflux.h"
# include "ncroms_physflux.h"
#endif
#ifdef WKB_WWAVE
# include "wkb_wwave.h"
#endif
#ifdef MPI
# ifdef HOFFMAN2
      include "mpif.h"
# else
# include "mpif.h"
# endif
#endif
      character keyword*32, fname*64
      character(len=3), parameter :: end_signal='end'
      integer, parameter :: kwsize=32, testunit=40, input=15
      integer ierr, iargc, is,ie,  kwlen, lstr, lenstr
#ifdef SOLVE3D
     &                                            , itrc
#endif

! This is needed to avoid automatic promotion to 8-byte integer by
! compiler flag (e.g., Sun compiler or xlf_r on IBM p690).

      integer*4, parameter :: ione=1

! Check CPP-switches for consistency. This operation is split into
! multiple stages because the first subroutine, "check_switches1", is
! generated by special program cppcheck (file cppcheck.F) by examining
! and documention all CPP-switches appearing in "cppdefs.h" regardless
! of their context, and automatically generate a code to keep track of
! their status, as well as to traps multiply defined global
! configurations (project switches, such as PACIFIC, USWEST, DAMEE_B,
! etc).  The subsequent routines are to track locally-defined switches
! in few other places throughout the code (these routines are
! hand-written), and, finally, the last routine, "check_switches2"
! contains traps for mutually exclussive definitions of non-project
! switches (e.g. it traps multiply defined vertical mixing schemes or
! lateral boundary conditions; this code is also hand written). 
! All the checking routines codes are written in transparent mode:
! they assumed that error flag (ierr) is initialized at the entry and
! they add 1 for each error discovered.

      ierr=0                      ! <-- reset error counter
      call check_tiling (ierr)
      call check_switches1 (ierr)
#ifdef SOLVE3D
      call check_scoord_switches (ierr)
      call check_pre_step_switches (ierr)
      call check_step_uv1_switches (ierr)
      call check_step_uv2_switches (ierr)
      call check_step_t_switches (ierr) 
# ifdef LMD_KPP
      call check_kpp_switches (ierr)  
# endif
#endif
      call check_switches2 (ierr) 
      mpi_master_only call print_switches
      if (ierr.ne.0) return

! Use pre-set default startup filename for known applications, or
! get it as an argument from command line via iargc-getarg (override
! default). NOTE: The usage of the executable should be either
!
!              roms 
!        or
!              roms startup_file_name
!
! WITHOUT the UNIX redirection (<): roms < startup_file like it
! used to be.

#if defined SOLITON
      fname='roms.in.Soliton'
#elif defined SEAMOUNT
      fname='roms.in.Seamount'
#elif defined WAVE_RAD
      fname='roms.in.WaveRad'
#elif defined ISWAKE
      fname='roms.in.IsWake'
#elif defined UPWELLING
      fname='roms.in.Upwelling'
#elif defined GRAV_ADJ
      fname='roms.in.GravAdj'
#elif defined IBERIA
      fname='roms.in.Iberia'
#elif defined RIVER
      fname='roms.in.River'
#elif defined PACIFIC
      fname='pacific.in'
#elif defined PACIFIC_2D
      fname='pacific_2D.in'
#elif defined CANBAS2
c--      fname='canBas2.in'
c--      fname='cblanco.in'
      fname='unpr.in'
#elif defined SPIRAL
      fname='spiral.in'
#elif defined PACBIG
      fname='pacbig.in'
#elif defined NWPAC
      fname='nwp.in'
#elif defined SMSC
      fname='smsc.in'
#elif defined SMSC_SUB
      fname='smsc_sub.in'
#elif defined USWEST
      fname='mb_l1_safe.in'
c--      fname='roms.in.USW20'
c--      fname='roms.in.US_West'
#elif defined SCB_TEST
      fname='scb_test.in'
#elif defined DAMEE_B
      fname='roms.in.Atl4'
#else
      fname='roms.in'
#endif
#ifdef MPI
      if (mynode.eq.0 .and. iargc().eq.1) call getarg(ione,fname)
      call MPI_Bcast(fname,64,MPI_BYTE, 0, ocean_grid_comm, ierr)
#else
      if (iargc().eq.1) call getarg(ione,fname)
#endif
      wrthis(indxTime)=.false.
#ifdef AVERAGES
      wrtavg(indxTime)=.false.
#endif
#ifdef STATIONS
      wrtsta(indxTime)=.true.
#endif
#ifdef DIAGNOSTICS_EDDY
      wrtdiags_eddy(indxTime)=.false.
# ifdef AVERAGES
      wrtdiags_eddy_avg(indxTime)=.false.
# endif
#endif
! Read in keyword: keep trying, until keyword is found.
! ==== == ======== ==== ======= ===== ======= == ======

      call setup_kwds (ierr)
      open (input, file=fname, status='old', form='formatted', err=97)
   1   keyword='                                '
       read(input,'(A)',err=1,end=99) keyword
       if (ichar(keyword(1:1)).eq.33) goto 1
       is=1
   2   if (is.eq.kwsize) then
         goto 1
       elseif (keyword(is:is).eq.' ') then
         is=is+1
         goto 2
       endif
       ie=is
   3   if (keyword(ie:ie).eq.':') then
         keyword(ie:ie)=' '
         goto 4           !--> recognized keyword.
       elseif (keyword(ie:ie).ne.' ' .and. ie.lt.kwsize) then
         ie=ie+1
         goto 3
       endif
       goto 1
   4   kwlen=ie-is
       if (is.gt.1) keyword(1:kwlen)=keyword(is:is+kwlen-1)

! Read input parameters according to the keyword:
! ==== ===== ========== ========= == === ========

! Title

        if (keyword(1:kwlen).eq.'title') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) title
          lstr=lenstr(title)
          mpi_master_only write(*,'(/1x,A)') title(1:lstr)

! Time-stepping parameters

        elseif (keyword(1:kwlen).eq.'time_stepping') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ntimes, dt, ndtfast, ninfo
          mpi_master_only write(*,
     &  '(5x,A,I10,3x,A/9x,A,F11.4,2x,A/4x,A,I10,3x,A/6x,A,I10,3x,2A)'
     &    ) 'ntimes =',  ntimes, 'total number of 3D timesteps',
     &          'dt =',     dt,  'time step [sec] for 3D equations',
     &     'ndtfast =', ndtfast, 'mode-splitting ratio',
     &       'ninfo =',   ninfo, 'number of steps between runtime ',
     &                                              'diagnostics'

          dtfast=dt/dble(ndtfast)     ! set barotropic time step.

#ifdef SOLVE3D
! Vertical S-coordinates transformation. Note that "hc" may be chosen
! to be very large (infinity) if vertically uniform sigma is desired.

        elseif (keyword(1:kwlen) .eq. 'S-coord') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) theta_s, theta_b, hc
          mpi_master_only write(*,'(2(/4x,A,F10.5,3x,A))')
     &    'theta_s =', theta_s, 'vertical S-coordinate surface',
     &    'theta_b =', theta_b, 'and bottom stretching parameters'
          if (hc.lt.1000.) then
            mpi_master_only write(*,'(9x,A,F10.5,3x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          else
            mpi_master_only write(*,'(9x,A,ES14.5,3x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          endif

!--> Boussinesq  reference density.

        elseif (keyword(1:kwlen) .eq. 'rho0') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) rho0
          mpi_master_only write(*,'(7x,A,F10.4,3x,A)')  'rho0 =',
     &            rho0, 'Boussinesq reference density [kg/m^3].'

# ifndef NONLIN_EOS
!--> Parameters for linear equations of state.

        elseif (keyword(1:kwlen) .eq. 'lin_rho_eos') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) Tcoef, T0
#  ifdef SALINITY
     &                       , Scoef, S0
#  endif
          mpi_master_only write(*,'(4(6x,A,F10.4,3x,A/))')
     &      'Tcoef =', Tcoef,  'thermal expansion [kg/m^3/deg C]'
     &    , '   T0 =',    T0,  'reference temperature [deg C]'
#  ifdef SALINITY
     &    , 'Scoef =', Scoef,  'saline contraction [kg/m^3/PSU]'
     &    , '   S0 =',    S0,  'reference salinity [PSU]'
#  endif
# endif
#endif /* SOLVE3D */


#ifdef UV_VIS2
! Lateral viscosity coefficients.

        elseif (keyword(1:kwlen) .eq. 'lateral_visc') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) visc2
          mpi_master_only write(*,'(6x,A,ES10.3,3x,A)') 'visc2 =',
     &      visc2, 'horizontal Laplacian kinematic viscosity [m2/s]'


# if !defined EW_PERIODIC || !defined NS_PERIODIC 
! Lateral boundary slipperness.

        elseif (keyword(1:kwlen) .eq. 'gamma2') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) gamma2
          mpi_master_only write(*,'(5x,A,F4.1,5x,A)') 'gamma2 =',gamma2
     &     , 'slipperiness parameter: free-slip = +1, or no-slip = -1.'
# endif
#endif
#ifdef SOLVE3D
# ifdef TS_DIF2
! Horizontal Laplacian mixing coefficients for tracers.

        elseif (keyword(1:kwlen) .eq. 'tracer_diff2') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) (tnu2(itrc),itrc=1,NT)
          do itrc=1,NT
            mpi_master_only write(*,'(ES10.3,A,I2,2A/32x,A,I2,A)')
     &      tnu2(itrc), '  tnu2(',itrc,')     Horizontal Laplacian ',
     &      'diffusion coefficient (m2/s)', 'for tracer ',  itrc, '.'
          enddo
# endif
#endif

! Bottom drag coefficients.

        elseif (keyword(1:kwlen) .eq. 'bottom_drag') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) rdrg, rdrg2
#ifdef SOLVE3D
     &                             , Zob
#endif
          mpi_master_only write(*,'(3(/7x,A,ES10.3,3x,A))')
     &    'rdrg =', rdrg,  'linear bottom drag coefficient [m/s]'
     &  , 'rdrg2=', rdrg2, 'quadratic bottom drag coefficient, nondim'
#ifdef SOLVE3D
     &  , ' Zob =', Zob,   'bottom roughness height [m]'
#endif

#ifdef SOLVE3D
# if !defined LMD_MIXING && !defined BVF_MIXING && !defined PP_MIXING\
                         && !defined MY2_MIXING && !defined MY25_MIXING

! Background vertical viscosity and mixing coefficients for tracers.

        elseif (keyword(1:kwlen) .eq. 'vertical_mixing') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) Akv_bak,(Akt_bak(itrc),itrc=1,NT)
          mpi_master_only write(*,'(4x,A,ES10.3,3x,A)')  'Akv_bak =',
     &               Akv_bak, 'background vertical viscosity [m^2/s]'
          do itrc=1,NT
            mpi_master_only write(*,'(1x,A,I1,A,ES10.3,3x,2A)')
     &                     'Akt_bak(',  itrc,  ') =',  Akt_bak(itrc),
     &                     'background vertical mixing [m^2/s] for ',
     &        vname(2,indxT+itrc-1)(1:lenstr(vname(2,indxT+itrc-1)))
          enddo
# endif
# ifdef MY25_MIXING
! Mellor-Yamada Level 2.5 turbulent closure parameters.

        elseif (keyword(1:kwlen) .eq. 'MY_bak_mixing') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) Akq_bak, q2nu2, q2nu4
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')  'Akq_bak =',
     &          Akq_bak, 'Background vertical mixing for TKE, [m2/s]'
#  ifdef Q_DIF2
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')    'q2nu2 =',
     &           q2nu2, 'Horizontal Laplacian mixing for TKE, [m2/s]'
#  endif
#  ifdef Q_DIF4
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')    'q2nu4 =',
     &          q2nu4, 'Horizontal biharmonic mixing for TKE, [m4/s]'
#  endif
# endif
#endif /* SOLVE3D */

#if  defined T_FRC_BRY || defined M2_FRC_BRY || defined TNUDGING \
  || defined Z_FRC_BRY || defined M3_FRC_BRY || defined M2NUDGING \
                       || defined M3NUDGING  || defined WKB_FRC_BRY

! Parameters for OBC nudging and nudging layers;
! converted from [days] to [sec^-1]

        elseif (keyword(1:kwlen) .eq. 'nudg_cof') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) tauM2_in, tauM2_out, attnM2
# ifdef SOLVE3D
     &                       , tauM3_in, tauM3_out
     &                       , tauT_in,  tauT_out
# endif
          if (tauM2_in.gt.0.) then               ! convert relaxation
            tauM2_in =1./(tauM2_in *day2sec)     ! time [units = days]
          endif                                  ! into
          if (tauM2_out.gt.0.) then              ! nudging coefficient
            tauM2_out=1./(tauM2_out*day2sec)     ! [units = 1/sec]
          endif
# ifdef SOLVE3D
          if (tauM3_in.gt.0.) then
            tauM3_in =1./(tauM3_in *day2sec)
          endif
          if (tauM3_out.gt.0.) then
            tauM3_out=1./(tauM3_out*day2sec)
          endif
          if (tauT_in.gt.0.) then
            tauT_in =1./(tauT_in *day2sec)
          endif
          if (tauT_out.gt.0.) then
            tauT_out=1./(tauT_out*day2sec)
          endif
# endif
          mpi_master_only write(*,'(6x,A,ES10.3,ES10.3,2A)')
     &          'tauM2 =', tauM2_in, tauM2_out, '(in/out)  Nudging ',
     &                                   'for barotropic mode [s^-1]'
          mpi_master_only write(*,'(5x,A,ES10.3,3x,2A)') 'attnM2 =',
     &    attnM2,'open boundary pressure-gradient attenuation [s^-1]'
# ifdef SOLVE3D
          mpi_master_only write(*,'(6x,A,ES10.3,ES10.3,2A)')
     &          'tauM3 =', tauM3_in, tauM3_out, '(in/out)  Nudging ',
     &                                   'for baroclinic mode [s^-1]'
          mpi_master_only write(*,'(7x,A,ES10.3,ES10.3,2A)')
     &             'tauT =', tauT_in, tauT_out, '(in/out)  Nudging ',
     &                                          'for tracers [s^-1]'
# endif
#endif
#ifdef SPONGE
! Parameters for the sponge layers

        elseif (keyword(1:kwlen) .eq. 'v_sponge') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) v_sponge
          mpi_master_only write(*,'(3x,A,F10.2,2x,A)') 'v_sponge =',
     &          v_sponge, 'Maximum viscosity in sponge layer [m2/s]'
#endif

!#if defined SALINITY && (defined QCORRECTION || defined SALINITY_RESTORING)
!        elseif (keyword(1:kwlen).eq.'salinity_restoring') then
!          call cancel_kwd (keyword(1:kwlen), ierr)
!          read(input,*,err=95) dSdt,dSdh
!          MPI_master_only write(stdout,'(1pe10.3,2x,A,1x,A)')
!     &     dSdt, 'sss_time    Time scale for sea surface   ',
!     &                                 'salinity restoring, days.'
!          MPI_master_only write(stdout,'(1pe10.3,2x,A,1x,A)')
!     &     dSdh, 'sss_depth   Depth scale for sea surface  ',
!     &                                 'salinity restoring, m   .'
!         if (dSdt.gt.0.) then
!          dSdt =1./(dSdt *day2sec)   ! convert from relaxation time units into nudging coefficient
!         endif
!#endif


#ifdef OBC_FLUX_CORR
        elseif (keyword(1:kwlen) .eq. 'tau_obc') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) tau_obc
          mpi_master_only write(*,'(1x,A,ES10.3,2x,2A)')
     &      'tau_obc =',  tau_obc, 'OBC volume constraint ',
     &                              'relaxation period [days]'
          tau_obc=tau_obc*day2sec
#endif

! Input file controls:  grid, initial conditions, surface forcing, 
!----- ----- ---------  climatology, lateral boundary forcing data   

#ifndef ANA_GRID
! Grid file name. Check its availability.

        elseif (keyword(1:kwlen) .eq. 'grid') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          open(testunit,file=fname(1:lstr), status='old', err=97)
          close(testunit)
          grdname=fname(1:lstr)
          mpi_master_only write(*,'(1x,2A)') 'grid file: ',
     &                                     grdname(1:lstr)
#endif

! Initial conditions file name. Check its availability (in the case
! of analytical initial conditions and nrrec=0 initial conditions are
! created internally and no file is needed).

        elseif (keyword(1:kwlen) .eq. 'initial') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) nrrec
#ifdef ANA_INITIAL
          if (nrrec.gt.0) then
#endif
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
#if defined MPI && defined PARALLEL_FILES
            call insert_node (fname, lstr, mynode, NNODES, ierr)
#endif
            ininame=fname(1:lstr)
            mpi_master_only write(*,'(1x,A,I3,2x,3A)')
     &       'initial condition :: rec =', nrrec,  'file = ''',
     &                                   ininame(1:lstr), ''''
#ifdef ANA_INITIAL
          endif
#endif
#if !defined ANA_SMFLUX  ||  defined SOLVE3D  &&\
   ( !defined ANA_STFLUX  ||\
     (defined SG_BBL96    && !defined ANA_BSEDIM) ||\
     (defined SG_BBL96    && !defined ANA_WWAVE)  ||\
     (defined QCORRECTION && !defined ANA_SST)    ||\
     (defined SALINITY    && !defined ANA_SSFLUX) ||\
     (defined LMD_KPP     && !defined ANA_SRFLUX))
 

! Forcing file name. Check its availability.
# if !defined BULK_FLUX
        elseif (keyword(1:kwlen) .eq. 'forcing') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          max_frc=0
          lstr=1
          do while (lstr.gt.0 .and. max_frc.lt.max_frc_file)
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
            if (lstr.gt.0) then
#  if defined MPI && defined PARALLEL_FILES
              call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
              open (testunit,file=fname(1:lstr),status='old',err=97)
              close(testunit)
              max_frc=max_frc+1
              frcfile(max_frc)=fname(1:lstr)
              if (max_frc.eq.1) then
                 mpi_master_only write(*,'(1x,A,1x,A)')
     &           'forcing data file(s):', frcfile(max_frc)(1:lstr)
              else
                 mpi_master_only write(*,'(23x,A)')
     &                                    frcfile(max_frc)(1:lstr)
              endif
            endif
          enddo
# endif /* !BULK_FLUX */
! Bulk file name. Check its availability.
# if defined BULK_FLUX
        elseif (keyword(1:kwlen) .eq. 'bulk_forcing') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          max_blk=0
          lstr=1
          do while (lstr.gt.0 .and. max_blk.lt.max_blk_file)
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
            if (lstr.gt.0) then
#  if defined MPI && defined PARALLEL_FILES
              call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
              open (testunit,file=fname(1:lstr),status='old',err=97)
              close(testunit)
              max_blk=max_blk+1
              blkfile(max_blk)=fname(1:lstr)
              if (max_blk.eq.1) then
                 mpi_master_only write(*,'(1x,A,1x,A)')
     &           'forcing data file(s):', blkfile(max_blk)(1:lstr)
              else
                 mpi_master_only write(*,'(23x,A)')
     &                                    blkfile(max_blk)(1:lstr)
              endif
            endif
          enddo
# endif /* BULK_FLUX */
#endif 


#if defined PSOURCE && !defined ANA_PSOURCE

! Point source file name. Check its availability.

        elseif (keyword(1:kwlen) .eq. 'point_source') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          open(testunit,file=fname(1:lstr), status='old', err=97)
          close(testunit)
          psrc_file=fname(1:lstr)
          mpi_master_only write(*,'(1x,3A)')
     &       'point source file = ''', psrc_file(1:lstr), ''''
#endif


! Climatology file name. Climatology data is needed for (1) to supply
! boundary data for T,S,u,v at open boundaries (just one row of points)
! and (2) nudging to T,S data inside the domain within the  nudging
! finite-width band near the boundary [although depreciated,  this
! practice  remains in some applications; doing so for u,v is no
! longer supported by this code].  Aternatively to (1), the boundary
! data may also be supplied via BRY mechanism, where file contains
! perimeter data only.  In this case (activated by T_FRC_BRY), no   
! climatology file is needed.  The following code segments also 
! checks for availability of clm_file.

#if defined SOLVE3D &&( defined TCLIMATOLOGY ||( defined TNUDGING &&\
                        defined T_FRC_BRY )) && !defined ANA_TCLIMA

        elseif (keyword(1:kwlen) .eq. 'climatology') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          open (testunit, file=fname(1:lstr), status='old', err=97)
          close(testunit)
          clm_file=fname(1:lstr)
          mpi_master_only write(*,'(1x,4A)')   'climatology data :: ',
     &                           'file = ''', clm_file(1:lstr), ''''
#endif
#if defined T_FRC_BRY || defined M2_FRC_BRY || defined M3_FRC_BRY \
                      || defined Z_FRC_BRY  || defined WKB_FRC_BRY
# ifndef ANA_BRY
! Boundary forcing data file name. Check availability.

        elseif (keyword(1:kwlen) .eq. 'boundary') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          open (testunit, file=fname(1:lstr), status='old', err=97)
          close(testunit)
          bry_file=fname(1:lstr)
          mpi_master_only write(*,'(1x,2A)') 'boundary forcing file: ',
     &                                              bry_file(1:lstr)
# endif
#endif

! Output files controls: restart, history, averages, stations, floats
!------- ----- ---------

        elseif (keyword(1:kwlen) .eq. 'restart') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) nrst, nrpfrst
          read(input,'(A)',err=95)  fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          rstname=fname(1:lstr)
          mpi_master_only write(*,'(1x,A,I8, 2x,A,I5, 2x,3A)')
     &          'restart :: nrst =',nrst, 'rec/file =', nrpfrst,
     &                        'file =''', rstname(1:lstr), ''''

! history file controls: owerwrite flag, output frequency,
! number of reconds per file in sequence, and filename 

        elseif (keyword(1:kwlen) .eq. 'history') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ldefhis, nwrt, nrpfhis
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          hisname=fname(1:lstr)
          mpi_master_only write(*,'(/1x,A,L1,2x,A,I5,2x,A,I4,2x,3A)')
     &       'history :: overwrite = ', ldefhis,      'nwrt =', nwrt,
     &       'rec/file =', nrpfhis, 'file = ''', hisname(1:lstr), ''''

! Which fields to be saved into history file.

        elseif (keyword(1:kwlen) .eq. 'primary_history_fields') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrthis(indxZ),  wrthis(indxUb)
     &                                      ,  wrthis(indxVb)
#ifdef SOLVE3D
     &                      ,  wrthis(indxU),  wrthis(indxV)
     &                      , (wrthis(indxT+itrc-1), itrc=1,NT)
# ifdef SEDIMENT_BIOLOGY
     &                      , (wrthis(itrc), 
     &                         itrc=indxSedFirst,indxSedFirst+NT_sed-1)
# endif /* SEDIMENT_BIOLOGY */
#endif
          if ( wrthis(indxZ) .or. wrthis(indxUb) .or. wrthis(indxVb)
#ifdef SOLVE3D
     &                         .or. wrthis(indxU) .or. wrthis(indxV)
#endif
     &       ) wrthis(indxTime)=.true.
 
          mpi_master_only write(*,'(/1x,A,5(/8x,A,T16,L1,T20,A))')
     &                   'fields to write into history file: (T/F)'
     &                 , 'zeta',   wrthis(indxZ),    vname(2,indxZ)
     &                 , 'ubar',   wrthis(indxUb),   vname(2,indxUb)
     &                 , 'vbar',   wrthis(indxVb),   vname(2,indxVb)
#ifdef SOLVE3D
     &                 , 'u',      wrthis(indxU),    vname(2,indxU)
     &                 , 'v',      wrthis(indxV),    vname(2,indxV)
          do itrc=1,NT
            if (wrthis(indxT+itrc-1)) wrthis(indxTime)=.true.
            mpi_master_only write(*,'(8x,A,I2,A,T16,L1,T20,A)') 't(',
     &        itrc, ')', wrthis(indxT+itrc-1), vname(2,indxT+itrc-1)
          enddo
# ifdef SEDIMENT_BIOLOGY
          do itrc = 1, NT_sed
            if (wrthis(indxSedFirst+itrc-1)) wrthis(indxTime)=.true.
            mpi_master_only write(*, '(6x,L1,2x,A,I2,A,I2,A)')
     &           wrthis(indxSedFirst+itrc-1), 'write T_sed(', 
     &           itrc,')  Sediment tracer of index ', itrc,'.' 
          end do
# endif /* SEDIMENT_BIOLOGY */

        elseif (keyword(1:kwlen) .eq. 'auxiliary_history_fields') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrthis(indxR), wrthis(indxO)
     &          ,  wrthis(indxW),  wrthis(indxAkv),  wrthis(indxAkt)
# ifdef SALINITY
     &                                            ,  wrthis(indxAks)
# endif
# ifdef LMD_KPP
     &                                            ,  wrthis(indxHbls)
# endif
# ifdef LMD_BKPP
     &                                           ,  wrthis(indxHbbl)
# endif
          if ( wrthis(indxR) .or. wrthis(indxO) .or. wrthis(indxW)
     &                     .or. wrthis(indxAkv) .or. wrthis(indxAkt)
# ifdef SALINITY
     &                                          .or. wrthis(indxAks)
# endif
# ifdef LMD_KPP
     &                                          .or. wrthis(indxHbls)
# endif
# ifdef LMD_BKPP
     &                                          .or. wrthis(indxHbbl)
# endif
     &       ) wrthis(indxTime)=.true.
 

          mpi_master_only write(*,'(8(/8x,A,T16,L1,T20,A))')
     &                   'rho',    wrthis(indxR),    vname(2,indxR)
     &                 , 'Omega',  wrthis(indxO),    vname(2,indxO)
     &                 , 'W',      wrthis(indxW),    vname(2,indxW)
     &                 , 'Akv',    wrthis(indxAkv),  vname(2,indxAkv)
     &                 , 'Akt',    wrthis(indxAkt),  vname(2,indxAkt)
# ifdef SALINITY
     &                 , 'Aks',    wrthis(indxAks),  vname(2,indxAks)
# endif
# ifdef LMD_KPP
     &                 , 'hbls',   wrthis(indxHbls), vname(2,indxHbls)
# endif
# ifdef LMD_BKPP
     &                 , 'hbbl',   wrthis(indxHbbl), vname(2,indxHbbl)
# endif
#endif /* SOLVE3D */


#ifdef AVERAGES
! Averages controls: time step number to start averaging (sets phase
! for averaging windows); averaging interval in time steps; number of
! records per file, and output filename.

        elseif (keyword(1:kwlen) .eq. 'averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ntsavg, navg, nrpfavg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          avgname=fname(1:lstr)
          mpi_master_only write(*,'(/1x,A,I5,2x,A,I5,2x,A,I4,2x,3A)')
     &       'averages :: ntsavg = ', ntsavg,      'navg =', navg,
     &       'rec/file =', nrpfavg, 'file = ''', avgname(1:lstr), ''''

! Switches for fields to compute averages.

        elseif (keyword(1:kwlen) .eq. 'primary_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtavg(indxZ),  wrtavg(indxUb)
     &                                        ,  wrtavg(indxVb)
# ifdef SOLVE3D
     &                      ,  wrtavg(indxU),     wrtavg(indxV)
     &                      , (wrtavg(indxT+itrc-1), itrc=1,NT)
#  ifdef SEDIMENT_BIOLOGY
     &                      , (wrtavg(itrc), 
     &                         itrc=indxSedFirst,indxSedFirst+NT_sed-1)
#  endif /* SEDIMENT_BIOLOGY */
# endif
          if ( wrtavg(indxZ) .or. wrtavg(indxUb) .or. wrtavg(indxVb)
# ifdef SOLVE3D
     &                       .or. wrtavg(indxU)  .or. wrtavg(indxV)
# endif
     &       ) wrtavg(indxTime)=.true.
 
          mpi_master_only write(*,'(/1x,A,5(/8x,A,T16,L1,T20,A))')
     &                   'fields to compute time averages of: (T/F)'
     &                 , 'zeta',   wrtavg(indxZ),    vname(2,indxZ)
     &                 , 'ubar',   wrtavg(indxUb),   vname(2,indxUb)
     &                 , 'vbar',   wrtavg(indxVb),   vname(2,indxVb)
#ifdef SOLVE3D 
     &                 , 'u',      wrtavg(indxU),    vname(2,indxU)
     &                 , 'v',      wrtavg(indxV),    vname(2,indxV)
          do itrc=1,NT
            if (wrtavg(indxT+itrc-1)) wrtavg(indxTime)=.true.
            mpi_master_only write(*,'(8x,A,I2,A,T16,L1,T20,A)') 't(',
     &        itrc, ')', wrtavg(indxT+itrc-1), vname(2,indxT+itrc-1)
          enddo
 
        elseif (keyword(1:kwlen) .eq. 'auxiliary_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtavg(indxR), wrtavg(indxO)
     &          ,  wrtavg(indxW),  wrtavg(indxAkv),  wrtavg(indxAkt)
#  ifdef SALINITY
     &                                            ,  wrtavg(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                            ,  wrtavg(indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                                            ,  wrtavg(indxHbbl)
#  endif
          if ( wrtavg(indxR) .or. wrtavg(indxO) .or. wrtavg(indxW)
     &                     .or. wrtavg(indxAkv) .or. wrtavg(indxAkt)
#  ifdef SALINITY
     &                                          .or. wrtavg(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                          .or. wrtavg(indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                                          .or. wrtavg(indxHbbl)
#  endif
     &       ) wrtavg(indxTime)=.true.
 
          mpi_master_only write(*,'(8(/8x,A,T16,L1,T20,A))')
     &                   'rho',    wrtavg(indxR),    vname(2,indxR)
     &                 , 'Omega',  wrtavg(indxO),    vname(2,indxO)
     &                 , 'W',      wrtavg(indxW),    vname(2,indxW)
     &                 , 'Akv',    wrtavg(indxAkv),  vname(2,indxAkv)
     &                 , 'Akt',    wrtavg(indxAkt),  vname(2,indxAkt)
#  ifdef SALINITY
     &                 , 'Aks',    wrtavg(indxAks),  vname(2,indxAks)
#  endif
#  ifdef LMD_KPP
     &                 , 'hbls',   wrtavg(indxHbls), vname(2,indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                 , 'hbbl',   wrtavg(indxHbbl), vname(2,indxHbbl)
#  endif
# ifdef OUTPUT_AVG_PHYS_BIO
!
! Averages file name for bgc variables
!
      elseif (keyword(1:kwlen).eq.'averages_bio') then
        call cancel_kwd (keyword(1:kwlen), ierr)
        read(input,*,err=95) nts_bio_avg, n_bio_avg, nrpf_bio_avg
        read(input,'(A)',err=95) fname
        lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
        call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
        bio_avgname=fname(1:lstr)
        mpi_master_only write(*,
     &         '(2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      nts_bio_avg, 'nts_bio_avg      Starting timestep for the',
     &         'accumulation of output', 'time-averaged biology data.',
     &      n_bio_avg,   'n_bio_avg        Number of timesteps between',
     &     'writing of time-averaged','data into biology averages file.',
     &     'Averages File:', bio_avgname(1:lstr),
     &     'rec/file =', nrpf_bio_avg
# endif /* OUTPUT_AVG_PHYS_BIO */

#ifdef OUTPUT_SST_AVG
!
! Averages file name.
!
      elseif (keyword(1:kwlen).eq.'SST_averages') then
        call cancel_kwd (keyword(1:kwlen), ierr)
        read(input,*,err=95) nts_sst_avg, n_sst_avg, nrpf_sst_avg
        read(input,'(A)',err=95) fname
        lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
        call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
        sst_avgname=fname(1:lstr)
        mpi_master_only write(*,
     &         '(2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      nts_sst_avg, 'ntsavg      Starting timestep for the',
     &         'accumulation of output', 'time-averaged SST data.',
     &      n_sst_avg,   'navg        Number of timesteps between',
     &     'writing of time-averaged','data into SST averages file.',
     &     'SST averages File:', sst_avgname(1:lstr),
     &     'rec/file =', nrpf_sst_avg
#endif /* OUTPUT_SST_AVG */
# endif /* SOLVE3D */
#endif /* AVERAGES */
#ifdef BGC_FLUX_ANALYSIS
!
! File name for histories of biogeochemical fluxes
!
        elseif (keyword(1:kwlen).eq.'bgc_flux_histories') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_bgc_flux_his,
     &         n_bgc_flux_his, nrpf_bgc_flux_his
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          bgc_flux_his_name=fname(1:lstr)
          mpi_master_only write(*,
     &           '(I10,2x,A,1x,A/32x,A/,6x,A,2x,A,1x,A,I3)')
     &      n_bgc_flux_his,   
     &         'n_bgc_flux_his     Number of timesteps between',
     &     'writing of',
     &         ' biogeochemical fluxes into file.',
     &     'Biogeochemical flux file:', 
     &         bgc_flux_his_name(1:lstr),
     &     'rec/file =', nrpf_bgc_flux_his

# ifdef AVERAGES
!
! File name for averages of biogeochemical fluxes
!
        elseif (keyword(1:kwlen).eq.'bgc_flux_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_bgc_flux_avg,
     &         nts_bgc_flux_avg, n_bgc_flux_avg, nrpf_bgc_flux_avg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          bgc_flux_avg_name=fname(1:lstr)
          mpi_master_only write(*,
     &           '(2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      nts_bgc_flux_avg, 
     &         'nts_bgc_flux_avg   Starting timestep for the',
     &           ' accumulation of output', 
     &         ' time-averaged biogeochemical fluxes.',
     &      n_bgc_flux_avg,   
     &         'n_bgc_flux_avg     Number of timesteps between',
     &     'writing of',
     &         ' time-averaged biogeochemical fluxes into file.',
     &     'Averaged biogeochemical flux file:', 
     &         bgc_flux_avg_name(1:lstr),
     &     'rec/file =', nrpf_bgc_flux_avg
# endif /* AVERAGES */
#endif /* BGC_FLUX_ANALYSIS */
#ifdef PHYS_FLUX_ANALYSIS
!
! File name for histories of physical fluxes
!
        elseif (keyword(1:kwlen).eq.'phys_flux_histories') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_phys_flux_his,
     &         n_phys_flux_his, nrpf_phys_flux_his
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          phys_flux_his_name=fname(1:lstr)
          mpi_master_only write(*,
     &           '(I10,2x,A,1x,A/32x,A/,6x,A,2x,A,1x,A,I3)')
     &      n_phys_flux_his,
     &         'n_phys_flux_his    Number of timesteps between',
     &     ' writing of',
     &         ' physical fluxes into file.',
     &     'Physical flux file:',
     &         phys_flux_his_name(1:lstr),
     &     'rec/file =', nrpf_phys_flux_his

# ifdef AVERAGES
!
! File name for averages of physical fluxes
!
        elseif (keyword(1:kwlen).eq.'phys_flux_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_phys_flux_avg,
     &         nts_phys_flux_avg, n_phys_flux_avg,
     &         nrpf_phys_flux_avg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif
          phys_flux_avg_name=fname(1:lstr)

#  ifdef PFA_BY_TRACER
          read(input,*,err=95) (wrt_pfa(itrc), itrc=1,NT)
#  endif
          mpi_master_only write(*,
     &           '(2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      nts_phys_flux_avg,
     &         'nts_phys_flux_avg  Starting timestep for the',
     &           ' accumulation of output',
     &         ' time-averaged physical fluxes.',
     &      n_phys_flux_avg,
     &         'n_phys_flux_avg    Number of timesteps between',
     &     ' writing of',
     &         ' time-averaged physical fluxes into file.',
     &     'Averaged physical flux file:',
     &         phys_flux_avg_name(1:lstr),
     &     'rec/file =', nrpf_phys_flux_avg
#  ifdef PFA_BY_TRACER
          do itrc=1,NT
            mpi_master_only write(*, '(6x,L1,2x,A,I2,A,I2,A)')
     &                       wrt_pfa(itrc), 
     &            ' write PFA_avg for tracer of index ', itrc,'.'
          enddo
#  endif
# endif /* AVERAGES */
#endif /* PHYS_FLUX_ANALYSIS */

#ifdef BULK_DIAGS
!
! File name for histories of bulk diags
!
        elseif (keyword(1:kwlen).eq.'bulk_diags_histories') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_bulk_diags_his,
     &         n_bulk_diags_his, nrpf_bulk_diags_his
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
          bulk_diags_his_name=fname(1:lstr)
          mpi_master_only write(*,
     &           '(I10,2x,A,1x,A/32x,A/,6x,A,2x,A,1x,A,I3)')
     &      n_bulk_diags_his,
     &         'n_bulk_diags_his    Number of timesteps between',
     &     ' writing of',
     &         ' bulk diags into file.',
     &     'Bulk Diags file:',
     &         bulk_diags_his_name(1:lstr),
     &     'rec/file =', nrpf_bulk_diags_his
          mpi_master_only write(*,*) 'new_bulk_diags_his',
     &                                new_bulk_diags_his

# ifdef AVERAGES
!
! File name for averages of physical fluxes
!
        elseif (keyword(1:kwlen).eq.'bulk_diags_averages') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) new_bulk_diags_avg,
     &         nts_bulk_diags_avg, n_bulk_diags_avg,
     &         nrpf_bulk_diags_avg
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
#  if defined MPI && defined PARALLEL_FILES
          call insert_node (fname, lstr, mynode, NNODES, ierr)
#  endif

          bulk_diags_avg_name=fname(1:lstr)

          mpi_master_only write(*,
     &           '(2(I10,2x,A,1x,A/32x,A/),6x,A,2x,A,1x,A,I3)')
     &      nts_bulk_diags_avg,
     &         'nts_bulk_diags_avg  Starting timestep for the',
     &           ' accumulation of output',
     &         ' time-averaged physical fluxes.',
     &      n_bulk_diags_avg,
     &         'n_bulk_diags_avg    Number of timesteps between',
     &     ' writing of',
     &         ' time-averaged physical fluxes into file.',
     &     'Averaged physical flux file:',
     &         bulk_diags_avg_name(1:lstr),
     &     'rec/file =', nrpf_bulk_diags_avg
          mpi_master_only write(*,*) 'new_bulk_diags_his',
     &                                new_bulk_diags_his

# endif /* AVERAGES */
#endif /* BULK_DIAGS */



#ifdef STATIONS
! Stations control: file with station locations; output
! interval and number of records per file; output filename: 

        elseif (keyword(1:kwlen) .eq. 'stations') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) nsta, nrpfstn
          read(input,'(A)',err=95) fname
          read(input,'(A)',err=95) staname
          lstr=lenstr(fname)

          mpi_master_only write(*,'(1x,A,I5,2x,A,I4,2x,3A/13x,3A)')
     &            'stations :: nsta =', nsta,  'rec/file =', nrpfstn,
     &            'positions file = ''', fname(1:lstr), '''',
     &            'output file = ''', staname(1:lenstr(staname)), ''''

          call read_sta_pos (fname,ierr)

! Switches for fields to sample into stations file: 

        elseif (keyword(1:kwlen) .eq. 'primary_stations') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtsta(indxZ),  wrtsta(indxUb)
     &                                         , wrtsta(indxVb)
# ifdef SOLVE3D
     &                      ,  wrtsta(indxU),     wrtsta(indxV)
     &                      , (wrtsta(indxT+itrc-1), itrc=1,NT)
# endif
          if ( wrtsta(indxZ) .or. wrtsta(indxUb) .or. wrtsta(indxVb)
# ifdef SOLVE3D
     &                       .or. wrtsta(indxU)  .or. wrtsta(indxV)
# endif
     &       ) wrtsta(indxTime)=.true.

          mpi_master_only write(*,'(/1x,A,5(/8x,A,T16,L1,T20,A))')
     &                   'fields to sample into stations file: (T/F)'
     &                 , 'zeta',   wrtsta(indxZ),    vname(2,indxZ)
     &                 , 'ubar',   wrtsta(indxUb),   vname(2,indxUb)
     &                 , 'vbar',   wrtsta(indxVb),   vname(2,indxVb)
#ifdef SOLVE3D
     &                 , 'u',      wrtsta(indxU),    vname(2,indxU)
     &                 , 'v',      wrtsta(indxV),    vname(2,indxV)
          do itrc=1,NT
            if (wrtsta(indxT+itrc-1)) wrtsta(indxTime)=.true.
            mpi_master_only write(*,'(8x,A,I2,A,T16,L1,T20,A)') 't(',
     &        itrc, ')', wrtsta(indxT+itrc-1), vname(2,indxT+itrc-1)
          enddo

        elseif (keyword(1:kwlen) .eq. 'auxiliary_stations') then
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtsta(indxR), wrtsta(indxO)
     &          ,  wrtsta(indxW),  wrtsta(indxAkv),  wrtsta(indxAkt)
#  ifdef SALINITY
     &                                            ,  wrtsta(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                            ,  wrtsta(indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                                            ,  wrtsta(indxHbbl)
#  endif
          if ( wrtsta(indxR) .or. wrtsta(indxO) .or. wrtsta(indxW)
     &                     .or. wrtsta(indxAkv) .or. wrtsta(indxAkt)
#  ifdef SALINITY
     &                                          .or. wrtsta(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                          .or. wrtsta(indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                                          .or. wrtsta(indxHbbl)
#  endif
     &       ) wrtsta(indxTime)=.true.

          mpi_master_only write(*,'(8(/8x,A,T16,L1,T20,A))')
     &                   'rho',    wrtsta(indxR),    vname(2,indxR)
     &                 , 'Omega',  wrtsta(indxO),    vname(2,indxO)
     &                 , 'W',      wrtsta(indxW),    vname(2,indxW)
     &                 , 'Akv',    wrtsta(indxAkv),  vname(2,indxAkv)
     &                 , 'Akt',    wrtsta(indxAkt),  vname(2,indxAkt)
#  ifdef SALINITY
     &                 , 'Aks',    wrtsta(indxAks),  vname(2,indxAks)
#  endif
#  ifdef LMD_KPP
     &                 , 'hbls',   wrtsta(indxHbls), vname(2,indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                 , 'hbbl',   wrtsta(indxHbbl), vname(2,indxHbbl)
#  endif
# endif /* SOLVE3D */
#endif /* STATIONS */


#ifdef FLOATS
! Floats file name.

      elseif (keyword(1:kwlen) .eq. 'floats') then
        call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) ldefflt, nflt, nrpfflt
          read(input,'(A)',err=95) fposnam
          read(input,'(A)',err=95) fltname
# if defined MPI && defined PARALLEL_FILES
          call insert_node (fposname, lstr, mynode, NNODES, ierr)
# endif
          lstr=lenstr(fltname)
          mpi_master_only write(*,'(/1x,A,L1,2x,A,I5,2x,A,I4,2x,3A)')
     &       'floats :: overwrite = ', ldefflt,      'nflt =', nflt,
     &       'rec/file =', nrpfflt, 'file = ''', fltname(1:lstr), ''''

! Switches for fields to be saved into floats output file.

      elseif (keyword(1:kwlen).eq.'float_fields') then
        call cancel_kwd (keyword(1:kwlen), ierr)
# ifdef AGRIF
        if (Agrif_Root()) then
# endif
          read(input,*,err=95) wrtflt(indxfltGrd),
     &       wrtflt(indxfltTemp), wrtflt(indxfltSalt),
     &       wrtflt(indxfltRho),  wrtflt(indxfltVel)
          mpi_master_only write(*,'(/1x,A,5(/6x,l1,2x,A))')
     &      'fields to be saved in floats output  (T/F)'
     &     , wrtflt(indxfltGrd),   'write Grid location variables'
     &     , wrtflt(indxfltTemp),  'write temperature.'
     &     , wrtflt(indxfltSalt),  'write salinity.'
     &     , wrtflt(indxfltRho),   'write density.'
     &     , wrtflt(indxfltVel),   'write mean float velocity'
# ifdef AGRIF
        endif
# endif
#endif /* FLOATS */

#if defined BIOLOGY_BEC || defined BIOLOGY_NPZDOC
#ifdef READ_ATM_PCO2
! atmospheric pCO2
      elseif (keyword(1:kwlen).eq.'pCO2_atm') then
        call cancel_kwd (keyword(1:kwlen), ierr)
        read(input,*,err=95) pCO2_atm
        mpi_master_only write(*,'(F10.4,2x,A,1x,A)')
     &        pCO2_atm, 'pCO2_atm Atmospheric pCO2, ppm.'
#endif /* READ_ATM_PCO2 */

# ifdef VARIABLE_ANN_ATM_PCO2
        elseif (keyword(1:kwlen).eq.'start_year') then
          ! Year at which the simulation starts. This is needed for
          ! the computation of the atmospheric pCO2. It can be a 
          ! floating point number, e.g. 2002.5 if the run starts in
          ! the middle of 2002.
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) start_year
          mpi_master_only write(*,'(1pe10.3,2x,A,1x,A)')
     &       start_year, 'start_year   point in time (year) when',
     &       'simulation starts'
        elseif (keyword(1:kwlen).eq.'futr_scen') then
          ! Scenario used for computing future (i.e. past 1990.5) values
          ! of pCO2. Must be one of the following: S350, S450, S550,
          ! S650, S750, DS450, or DS550 from Enting et al. (1994), 
          ! or CIS9 signifying c-IS92A for IPCC (2000) run.
          call cancel_kwd (keyword(1:kwlen), ierr)
          read(input,*,err=95) futr_scen
          ! Test whether futr_scen contains a valid string:
          futr_scen_valid = .false.
          if (futr_scen(1:4) .eq. 'S350' .or. futr_scen(1:4) .eq. 'S450' .or.
     &        futr_scen(1:4) .eq. 'S550' .or. futr_scen(1:4) .eq. 'S650' .or.
     &        futr_scen(1:4) .eq. 'S750' .or. futr_scen(1:4) .eq. 'DS45' .or.
     &        futr_scen(1:4) .eq. 'DS55' .or. futr_scen(1:4) .eq. 'CIS9')
     &          futr_scen_valid = .true.
          if (.not. futr_scen_valid) then
             mpi_master_only write(*,'(3a)') 'Invalid value of ',
     &       'futr_scen: ', futr_scen
             goto 95
          end if
          mpi_master_only write(*,'(6x,A,2x,A,1x,A)')
     &      futr_scen , 'futr_scen   scenario for past 1990.5 values',
     &      'of atm. pCO2'
# endif /* VARIABLE_ANN_ATM_PCO2 */

# ifdef READ_VARIABLE_ATM_PCO2
! atmospheric pCO2
      elseif (keyword(1:kwlen).eq.'pCO2_atm_file') then
        call cancel_kwd (keyword(1:kwlen), ierr)
        read(input,'(A)',err=95) pco2_atm_file
        mpi_master_only write(*,'(A,A)')
     &        'Read atmospheric pCO2 from ', pco2_atm_file
# endif /* READ_VARIABLE_ATM_PCO2 */

#endif /* BIOLOGY_BEC || BIOLOGY_NPZDOC */

#if defined DIAGNOSTICS_EDDY
!
! Diagnostics Momentum file name.
!
      elseif (keyword(1:kwlen).eq.'diags_eddy') then
        call cancel_kwd (keyword(1:kwlen), ierr)
        read(input,*,err=95) ldefdiags_eddy, nwrtdiags_eddy, nrpfdiags_eddy
        read(input,'(A)',err=95) fname
        lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
        call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
        diags_eddyname=fname(1:lstr)
!
# ifdef AVERAGES
      elseif (keyword(1:kwlen).eq.'diags_eddy_avg') then
        call cancel_kwd (keyword(1:kwlen), ierr)
        read(input,*,err=95) ldefdiags_eddy_avg, ntsdiags_eddy_avg,
     &                       nwrtdiags_eddy_avg, nrpfdiags_eddy_avg
        read(input,'(A)',err=95) fname
        lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
        call insert_node (fname, lstr, mynode, NNODES, ierr)
# endif
        diags_eddy_avgname=fname(1:lstr)

# endif

!
! Switches for fields to be saved into momentum diagnostics file.
!
!!          wrtdiags_eddy=.true.
      elseif (keyword(1:kwlen).eq.'diags_eddy_history_fields') then
        call cancel_kwd (keyword(1:kwlen), ierr)
        read(input,*,err=95)  wrtdiags_eddy(2)
           if (wrtdiags_eddy(2)) wrtdiags_eddy(indxTime)=.true.

# ifdef AVERAGES
!!         wrtdiags_eddy_avg=.true.
      elseif (keyword(1:kwlen).eq.'diags_eddy_average_fields') then
        call cancel_kwd (keyword(1:kwlen), ierr)
        read(input,*,err=95) wrtdiags_eddy_avg(2)

          if (wrtdiags_eddy_avg(2)) wrtdiags_eddy_avg(indxTime)=.true.

# endif /* AVERAGES  */

#endif /*DIAGNOSTICS_EDDY */

        else
          mpi_master_only write(*,'(/1x,4A/)') 'WARNING: ',
     &                'Unrecognized keyword ''', keyword(1:kwlen),
     &                                      ''' --> DISREGARDED.'
        endif
       if (keyword(1:kwlen) .eq. end_signal) goto 99
      goto 1

! Error while reading input parameters.

  95  write(*,'(/1x,4A/)') '### ERROR: read_inp :: Cannot read ',
     &                       'entry ''', keyword(1:kwlen), '''.'
      ierr=ierr+1
      goto 99
  97  lstr=lenstr(fname)
      write(*,'(/1x,4A/)') '### ERROR: read_inp :: Cannot find ',
     &                     'input file ''', fname(1:lstr), '''.'
      ierr=ierr+1
  99  close (input)

! Check that all keywords were canceled, complain about the error,
! if some of them left.

      if (ierr.eq.0) call check_kwds (ierr)
      if (ierr.ne.0) then
        write(*,'(/1x,2A,I3,1x,A/)') '### ERROR: read_inp :: ',
     &  'A total of', ierr, 'configuration errors discovered.'
       return
      endif
      call check_srcs
#ifdef MPI
      call MPI_Barrier (ocean_grid_comm, ierr)
#endif
      return
      end

                                            ! Find place in the string
      subroutine cancel_kwd (keyword, ierr) ! kwds(1:max_opt_size)
      implicit none                         ! which matches the input
#include "strings.h"
      character(len=*) keyword              ! keyword name and turn it
      integer ierr, is,i,ie, lenkw,lenstr   ! into blank. Complain
      lenkw=lenstr(keyword)                 ! about error if not found.
      is=1
      do while (is.gt.0 .and. is.lt.max_opt_size)
        do while (kwds(is:is).eq.' ' .and. is.lt.max_opt_size)
          is=is+1
        enddo
        ie=is+1
        do while (kwds(ie:ie).ne.' ' .and. ie.lt.max_opt_size)
          ie=ie+1
        enddo
        if (lenkw.eq.ie-is .and. kwds(is:ie-1).eq.keyword) then
c**       write(*,'(1x,A,1x,A)') 'Recognized: ', kwds(is:ie-1)
          do i=is,ie-1
            kwds(i:i)=' '
          enddo
          is=0         !--> to signal that keyword is found and
        else           !                      terminate the search
          is=ie        !--> skip to the next word in "kwds" string
        endif
      enddo
      if (is.ne.0) then
        write(*,'(/A)') '##### ERROR #####'
        write(*,'(2(1x,A,1x,A,1x,A/)/)') 'cancel_kwd:',
     &         'Can not cancel keyword:',  keyword(1:lenkw),
     &         'check input script for possible',
     &         'duplicated keywords.'
        write(*,'(A/)') '#################'
        ierr=ierr+1
      endif
      return
      end

                                      ! Check that keyword string is
      subroutine check_kwds (ierr)    ! empty, and if it is not print
      implicit none                   ! out remaining keyword(s) as
#include "strings.h"
      integer ierr, is,ie             ! an error message and increase
      is=1                            ! error counter ierr.
      do while (is.lt.max_opt_size)
        do while (kwds(is:is).eq.' ' .and. is.lt.max_opt_size)
          is=is+1
        enddo
        if (is.lt.max_opt_size) then
          ie=is+1
          do while (kwds(ie:ie).ne.' ' .and. ie.lt.max_opt_size)
            ie=ie+1
          enddo
          ierr=ierr+1
          write(*,'(/1x,A,1x,A/)') '### ERROR: keyword not found:',
     &                                               kwds(is:ie-1)
          is=ie
        endif
      enddo
      return
      end
 
 
